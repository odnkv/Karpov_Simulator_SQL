# Курс «Симулятор SQL»

## 8 урок JOIN

<details>
Основные типы объединений `JOIN`
Вот мы и подобрались к одной из важнейших тем в SQL — объединению таблиц. 

SQL-запросы позволяют выбирать и обрабатывать данные не только из одной таблицы — в этом мы уже убедились, когда работали с подзапросами. Но таблицы можно также объединять в один результирующий набор записей, связывая их по определённым условиям. Это позволяет делать операция соединения `JOIN`.

В этом уроке мы рассмотрим следующие типы соединений таблиц:

INNER JOIN
LEFT/RIGHT JOIN
FULL JOIN
CROSS JOIN
Операторы соединения включаются в раздел `FROM` запроса. В общем виде, вне зависимости от того, какой тип соединения используется, запрос на объединение таблиц выглядит следующим образом:

```sql
SELECT ...
FROM table_1 
     JOIN table_2
     ON [condition]
...
```

Как правило (но далеко не всегда), в качестве условия [condition], по которому происходит объединение, выступает равенство значений в определённых столбцах. В качестве таких столбцов обычно используются ключи с указанием id (товара, пользователя и т.д.), то есть значений, по которым можно однозначно идентифицировать определённую сущность:

```sql
SELECT table_1.column_1, table_2.column_2
FROM table_1 
     JOIN table_2
     ON table_1.id = table_2.id
...
```


При этом у каждой колонки рекомендуется через точку указывать имя таблицы, которая содержит эту колонку. Более того, это становится уже не рекомендацией, а необходимостью, когда имена столбцов в таблицах совпадают — без явного указания источников база данных не сможет сама определить, какие столбцы и в каких таблицах вы имеете в виду, и в результате вернёт ошибку.

Если имена таблиц слишком длинные, таблицам можно присвоить алиасы. По этим же алиасам можно сразу удобно обращаться к колонкам:

```sql
SELECT a.column_1, b.column_2
FROM table_1 a 
     JOIN table_2 b
     ON a.id = b.id
...
```

Если имя поля, по которому происходит объединение, совпадает в обеих таблицах (как в примерах выше), то можно использовать сокращенную запись c оператором `USING`:

```sql
SELECT a.column_1, b.column_2
FROM table_1 a 
     JOIN table_2 b
     USING (id)
...
```


При объединении таблиц можно также использовать подзапросы. Их можно объединять с другими таблицами или друг с другом:

```sql
SELECT ...
FROM table_1
     JOIN (
          SELECT ...
          FROM table_2
     ) AS subquery
    ON table_1.id = subquery.id
...
```

```sql
SELECT ...
FROM (
     SELECT ...
     FROM table_1
) AS subquery_1
     JOIN (
          SELECT ...
          FROM table_2
     ) AS subquery_2
    ON subquery_1.id = subquery_2.id
...
```

Хорошо, с записью в общем виде вроде бы понятно. Но что же на самом деле происходит при объединении таблиц? Давайте разбираться.

Процесс объединения можно представить в виде следующей последовательности операций:

Сначала каждая строка первой таблицы сопоставляется с каждой строкой второй таблицы. т.е. происходит декартово произведение двух множеств, результатом которого является новое множество, состоящее из всевозможных пар исходных строк. Например, если в одной таблице было 50 записей, а в другой 10, то в результате декартова произведения получится 500 записей. На игрушечном примере это можно представить следующим образом:

<img width="477" height="414" alt="image" src="https://github.com/user-attachments/assets/99414e1c-6243-479d-b931-4bda32537fcf" />

2. Затем для каждой объединённой строки, состоящей из строк двух исходных таблиц, проверяется условие соединения, указанное после оператора ON.

3. После этого в соответствии с выбранным типом объединения формируется результирующая таблица. 

При соединении не двух, а нескольких таблиц, операция соединения выполняется последовательно несколько раз, т.е. описанный выше алгоритм запускается столько раз, сколько указано соединений. При этом в этой последовательности при каждом объединении может использоваться любой тип соединения (INNER, LEFT и т.д.).

Для двух соединений запрос может выглядеть примерно следующим образом:

```sql
SELECT a.column_1, b.column_2
FROM table_1 a 
     LEFT JOIN table_2 b
     ON a.user_id = b.user_id
     JOIN table_3 c
     ON b.order_id = c.order_id
...
```

О том, как именно выбор типа `JOIN` влияет на результат, мы и будем говорить в этом уроке.

Если что-то на этом шаге осталось непонятным, не переживайте. Сейчас всё проясним на практических примерах!
</details>

### Практика

#### [Задача 1](https://lab.karpov.courses/learning/152/module/1762/lesson/17929/53217/257151)

<details>

Первый тип объединения, который мы рассмотрим, называется `INNER JOIN`. Это оператор внутреннего соединения, для которого совершенно неважен порядок указания таблиц, т.е. в следующих случаях результат объединения будет одинаковым:

```sql
SELECT ...
FROM table_1 INNER JOIN table_2
     ON [condition]
...


SELECT ...
FROM table_2 INNER JOIN table_1 
     ON [condition]
...
```

При этом в запросе вместо `INNER JOIN` можно писать просто `JOIN` — это одно и то же.

Результат объединения `INNER JOIN` формируется следующим образом:

Сначала каждая строка первой таблицы сопоставляется с каждой строкой второй таблицы (происходит декартово произведение).
Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора ON.
После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
Таким образом, в результате объединения `INNER JOIN` из двух таблиц отбрасываются все строки, которые не прошли проверку на соответствие указанному условию. Вот и всё!

Рассмотрим следующий игрушечный пример:

```sql
SELECT A.id as id,
       A.city as city,
       B.country as country
FROM table_A as A
     JOIN table_B as B
     ON A.id = B.id
```

В результате такого запроса таблицы table_A и table_B будут объединены в таблицу table_С:
<img width="633" height="253" alt="image" src="https://github.com/user-attachments/assets/4b898240-8999-4453-a4f3-32ab3fae8f69" />


Поскольку таблицы совпадают только по одному значению в столбце id, то в результат будет включена только одна запись.

Схематично результат работы объединений принято изображать в виде диаграмм Венна. Для `INNER JOIN` диаграмма выглядит так:
<img width="220" height="149" alt="image" src="https://github.com/user-attachments/assets/471dcc15-1313-4354-b9e5-def9b15bd41a" />

`На заметку:`

Подробнее про `INNER JOIN` можно почитать здесь.

А теперь давайте вернёмся к нашей базе данных и решим задачу.

Для начала попробуйте выполнить в Redash следующие два запроса и посчитать количество уникальных пользователей в таблицах `users` и `user_actions`:

```sql
SELECT COUNT(DISTINCT user_id)
FROM users


SELECT COUNT(DISTINCT user_id)
FROM user_actions
```

Вы заметите, что в таблице `user_actions` уникальных пользователей больше. Это значит, что про часть пользователей мы что-то не знаем — у нас попросту нет о них информации в таблице `users`. Поэтому в результате соединения этих двух таблиц с помощью `INNER JOIN` эта часть пользователей будет исключена из результата.

</details>

`Задание:` INNER JOIN

Объедините таблицы `user_actions` и `users` по ключу `user_id`. В результат включите две колонки с `user_id` из обеих таблиц. Эти две колонки назовите соответственно `user_id_left` и `user_id_right`. Также в результат включите колонки `order_id, time, action, sex, birth_date`. Отсортируйте получившуюся таблицу по возрастанию `id` пользователя (в любой из двух колонок с id).

Поля в результирующей таблице: `user_id_left, user_id_right,  order_id, time, action, sex, birth_date`

`Пояснение:`

Обратите внимание, что в результате объединения колонки с ключами (в нашем случае это user_id) не превращаются в одну общую колонку, а вместе добавляются в результирующую таблицу. То есть сколько было суммарно колонок в двух таблицах, столько окажется и в результирующей таблице после объединения. А уже далее в операторе `SELECT` можно выбирать нужные и проводить над ними операции.

Чтобы обратиться к колонкам с одинаковым именем (user_id), пришедшим из разных таблиц, назначьте таблицам алиасы и обратитесь к колонкам через них. Пример, как это можно сделать:

```sql
SELECT A.id as id_a, 
       B.id as id_b, 
       ...
FROM table_A as A
     JOIN table_B as B
     ON A.id = B.id
...
```

После того как решите задачу, обратите внимание на колонки с `user_id`. Все ли значения в них попарно совпадают?

```sql

SELECT u.user_id as user_id_left,
       ua.user_id as user_id_right,
       order_id,
       time,
       action,
       sex,
       birth_date
FROM   users as u join user_actions as ua
        ON u.user_id = ua.user_id
ORDER BY u.user_id asc

```

#### [Задача 2](https://lab.karpov.courses/learning/152/module/1762/lesson/17929/53217/257154)

`Задание:` INNER JOIN

А теперь попробуйте немного переписать запрос из прошлого задания и посчитать количество уникальных `id` в объединённой таблице. То есть снова объедините таблицы, но в этот раз просто посчитайте уникальные `user_id` в одной из колонок с `id`. Выведите это количество в качестве результата. Колонку с посчитанным значением назовите `users_count`.

Поле в результирующей таблице: `users_count`

После того как решите задачу, сравните полученное значение с количеством уникальных пользователей в таблицах `users` и `user_actions`, которое мы посчитали на прошлом шаге. С каким значением оно совпадает?

```sql

SELECT count(distinct u.user_id) as users_count
FROM   users as u join user_actions as ua
        ON u.user_id = ua.user_id

```

#### [Задача 3](https://lab.karpov.courses/learning/152/module/1762/lesson/17929/53217/257152)

<details>
Следующий тип соединения, который мы рассмотрим, — это `LEFT OUTER JOIN` (или просто `LEFT JOIN`). 

`LEFT JOIN` — это оператор внешнего соединения, для которого важен порядок таблиц в запросе, т.е. в отличие от `INNER JOIN` он не является симметричным.

Поэтому следующие две записи уже не являются эквивалентными:

```sql
SELECT ...
FROM table_1 LEFT JOIN table_2
     ON [condition]
...


SELECT ...
FROM table_2 LEFT JOIN table_1 
     ON [condition]
...
```

Результат объединения `LEFT JOIN` формируется следующим образом:

Сначала каждая строка левой таблицы сопоставляется с каждой строкой правой таблицы (происходит декартово произведение).
Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора `ON`.
После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
Далее в результат добавляются те записи из левой таблицы (внимание: только из левой), для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. При этом для таких записей соответствующие поля из правой таблицы заполняются значениями `NULL`.
Если внимательно посмотреть на описанный алгоритм, то можно понять, что он легко сводится к следующей последовательности действий:

Сначала в соответствии с указанным условием выполняется `INNER JOIN` первой и второй таблиц.
Затем в результат добавляются те записи из левой таблицы (внимание: только из левой), для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. При этом для таких записей соответствующие поля из правой таблицы заполняются значениями `NULL`.
Вот и вся магия!

Соединение `RIGHT JOIN` работает аналогичным образом, только на втором этапе в результат `INNER JOIN` добавляются записи не из левой, а из правой таблицы.

Давайте снова рассмотрим пару простых примеров.

Так будет выглядеть запрос и его результат с `LEFT JOIN`:

```sql
SELECT A.id as id,
       A.city as city,
       B.country as country
FROM table_A as A
     LEFT JOIN table_B as B
     ON A.id = B.id
```
<img width="602" height="271" alt="image" src="https://github.com/user-attachments/assets/50e788fb-8591-45a1-affe-2e905c068226" />


В данном случае в результат попадёт запись с id 2, так как она есть в обеих таблицах, а также запись с id 1 из левой таблицы.

Диаграмма Венна для `LEFT JOIN` выглядит так:
<img width="220" height="149" alt="image" src="https://github.com/user-attachments/assets/f35960a5-6a35-4185-97c6-8c9afb4adb8e" />


А вот таким получится результат запроса с `RIGHT JOIN`:

```sql
SELECT B.id as id,
       A.city as city,
       B.country as country
FROM table_A as A
     RIGHT JOIN table_B as B
     ON A.id = B.id
```
<img width="602" height="271" alt="image" src="https://github.com/user-attachments/assets/410998cd-877f-4e50-9dd2-5584e48a78e0" />


Всё как и в случае с `LEFT JOIN`, только в результат уже попадёт недостающая запись с id 3 из правой таблицы.

Диаграмма Венна для `RIGHT JOIN`:
<img width="220" height="149" alt="image" src="https://github.com/user-attachments/assets/234fd572-c2e6-4c9c-99f8-175d3365ff23" />

`На заметку:`

Подробнее про `LEFT JOIN` можно почитать здесь.

А теперь рассмотрим всё на примере наших данных.
</details>

`Задание:` LEFT JOIN

С помощью `LEFT JOIN` объедините таблицы `user_actions` и `users` по ключу `user_id`. 
Обратите внимание на порядок таблиц — слева `user_actions`, справа `users`. 
В результат включите две колонки с `user_id` из обеих таблиц. 
Эти две колонки назовите соответственно `user_id_left` и `user_id_right`. 
Также в результат включите колонки `order_id, time, action, sex, birth_date`. 
Отсортируйте получившуюся таблицу по возрастанию id пользователя (в колонке из левой таблицы).

Поля в результирующей таблице: `user_id_left, user_id_right,  order_id, time, action, sex, birth_date`

После того как решите задачу, обратите внимание на колонки с `user_id`. Нет ли в какой-то из них пропущенных значений?

```sql

SELECT
ua.user_id as user_id_left,
u.user_id as user_id_right,
order_id, time, action, sex, birth_date
FROM user_actions AS ua
LEFT JOIN users AS u
ON ua.user_id = u.user_id
ORDER BY ua.user_id ASC

```

#### [Задача 4](https://lab.karpov.courses/learning/152/module/1762/lesson/17929/53217/257155)

`Задание:` LEFT JOIN

Теперь снова попробуйте немного переписать запрос из прошлого задания и посчитайте количество уникальных `id` в колонке `user_id`, пришедшей из левой таблицы `user_actions`. Выведите это количество в качестве результата. Колонку с посчитанным значением назовите `users_count`.

Поле в результирующей таблице: `users_count`

После того как решите задачу, сравните полученное значение с количеством уникальных пользователей в таблицах `users` и `user_actions`. С каким значением оно совпало в этот раз?

```sql

SELECT
COUNT(DISTINCT ua.user_id) AS users_count
FROM user_actions AS ua
LEFT JOIN users AS u
ON ua.user_id = u.user_id

```

#### [Задача 5](https://lab.karpov.courses/learning/152/module/1762/lesson/17929/53217/257156)
<details>
Вы могли заметить, что при объединении таблиц `user_actions` и `users` с помощью `LEFT JOIN` в столбцах, пришедших из правой таблицы `users` образовались `NULL` значения. Если не заметили, то попробуйте прямо в интерфейсе Redash отсортировать объединённую таблицу по полям `users.user_id и users.birth_date`.

Это как раз то, о чём мы говорили — при формировании объединённых строк для тех `id` из левой таблицы, которых не оказалось в правой таблице, поля из правой таблицы были заполнены пустыми значениями.

А теперь давайте провернём один трюк.
</details>

`Задание:` LEFT JOIN

Возьмите запрос из задания 3, где вы объединяли таблицы `user_actions` и `users` с помощью `LEFT JOIN`, добавьте к запросу оператор `WHERE` и исключите `NULL` значения в колонке `user_id` из правой таблицы. Включите в результат все те же колонки и отсортируйте получившуюся таблицу по возрастанию `id` пользователя в колонке из левой таблицы.

Поля в результирующей таблице: `user_id_left, user_id_right,  order_id, time, action, sex, birth_date`

После того как решите задачу, попробуйте сдать это же решение в первом задании — сработает или нет? Подумайте, какой `JOIN` мы сейчас получили после всех манипуляций с результатом. Заодно можете посчитать число уникальных `user_id` в запросе из этого задания, чтобы расставить все точки над «i».


```sql

SELECT ua.user_id as user_id_left,
       u.user_id as user_id_right,
       order_id,
       time,
       action,
       sex,
       birth_date
FROM   user_actions as ua
    LEFT JOIN users as u
        ON ua.user_id = u.user_id
WHERE  u.user_id is not null
ORDER BY ua.user_id asc

```

#### [Задача 6](https://lab.karpov.courses/learning/152/module/1762/lesson/17929/53217/260434)

<details>

`FULL JOIN`
А чтобы лучше разобраться с джойнами, рассмотрим ещё один тип объединения таблиц — `FULL OUTER JOIN` или просто `FULL JOIN`. Это оператор полного внешнего соединения, для которого, как и для `INNER JOIN`, неважен порядок указания таблиц. Однако работает он совсем по-другому.

Запрос с `FULL OUTER JOIN` выглядит примерно так:

```sql

SELECT ...
FROM table_1 FULL JOIN table_2
     ON [condition]
...


SELECT ...
FROM table_2 FULL JOIN table_1 
     ON [condition]
...

```

Результат объединения `FULL JOIN` формируется следующим образом:

Сначала каждая строка левой таблицы сопоставляется с каждой строкой правой таблицы (происходит декартово произведение).
Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора ON.
После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
Далее в результат добавляются те записи из левой и правой таблиц (внимание: из обеих таблиц), для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. При этом для таких записей соответствующие поля из другой таблицы (для левой — это поля из правой, для правой — это поля из левой) заполняются значениями `NULL`.
Этот алгоритм можно свести к следующей последовательности действий:

Сначала в соответствии с указанным условием выполняется `INNER JOIN` левой и правой таблиц.
Далее в результат добавляются те записи из левой и правой таблиц (внимание: из обеих таблиц), для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. При этом для таких записей соответствующие поля из другой таблицы (для левой — это поля из правой, для правой — это поля из левой) заполняются значениями `NULL`.
Рассмотрим простой пример.

Так будет выглядеть запрос и его результат с `FULL JOIN`:

```sql
SELECT A.id as id,
       A.city as city,
       B.country as country
FROM table_A as A
     FULL JOIN table_B as B
     ON A.id = B.id
```

<img width="633" height="308" alt="image" src="https://github.com/user-attachments/assets/a34b6e21-1f5b-4de5-bfc4-070f43ec0cdd" />

В результат попала общая запись с id 2, а также все недостающие записи из других таблиц. Все несоответствия были заполнены пустыми значениями.

Диаграмма Венна для `FULL JOIN`:

<img width="220" height="149" alt="image" src="https://github.com/user-attachments/assets/093cfd43-f671-4ab5-9af8-fb235bb28931" />

`На заметку:`

Подробнее про `FULL JOIN` можно почитать здесь.

А теперь давайте разберёмся с `FULL JOIN` на примере нашей базы данных.

У нас есть две таблицы с датами рождения пользователей и курьеров — `users и couriers`. Можно предположить, что в каждой таблице в колонке `birth_date` есть какие-то даты, которых нет в другой таблице. То есть есть такие даты, в которые родился кто-то из курьеров, но не родился ни один пользователь, и наоборот. Ну что ж, давайте попробуем проверить эту гипотезу.

Для начала сгруппируем две таблицы по колонке `birth_date` и посчитаем, сколько пользователей/курьеров родились в каждый из дней. Для этого можете выполнить в Redash следующие запросы: 

```sql
SELECT birth_date, COUNT(user_id) AS users_count
FROM users
WHERE birth_date IS NOT NULL
GROUP BY birth_date


SELECT birth_date, COUNT(courier_id) AS couriers_count
FROM couriers
WHERE birth_date IS NOT NULL
GROUP BY birth_date
```

В результате у вас получатся две таблицы с уникальными датами и количеством людей, родившихся в каждый из дней. Давайте их объединим.


</details>

`Задание:` FULL JOIN

С помощью `FULL JOIN` объедините по ключу `birth_date` таблицы, полученные в результате вышеуказанных запросов (то есть объедините друг с другом два подзапроса). Не нужно изменять их, просто добавьте нужный `JOIN`.

В результат включите две колонки с `birth_date` из обеих таблиц. Эти две колонки назовите соответственно `users_birth_date` и `couriers_birth_date`. Также включите в результат колонки с числом пользователей и курьеров — `users_count` и `couriers_count`.

Отсортируйте получившуюся таблицу сначала по колонке `users_birth_date` по возрастанию, затем по колонке `couriers_birth_date` — тоже по возрастанию.

Поля в результирующей таблице: `users_birth_date, users_count,  couriers_birth_date, couriers_count`

После того как решите задачу, изучите полученную таблицу в Redash. Обратите внимание на пропущенные значения в колонках с датами рождения курьеров и пользователей. Подтвердилось ли наше предположение?

`Подсказка:`

Не меняете запросы из задачи, финальный запрос выглядит так:

```sql

SELECT  ...
    FROM ( 
        SELECT birth_date, COUNT(user_id) AS users_count 
        FROM users 
        WHERE birth_date IS NOT NULL 
        GROUP BY birth_date 
    ) a 
    FULL JOIN ( 
        SELECT birth_date, COUNT(courier_id) AS couriers_count 
        FROM couriers 
        WHERE birth_date IS NOT NULL 
        GROUP BY birth_date 
    ) b 
    USING(...) 
    ORDER BY ...

```


```sql

SELECT 
a.birth_date AS users_birth_date,
b.birth_date AS couriers_birth_date,
users_count,
couriers_count
    FROM ( 
        SELECT birth_date, COUNT(user_id) AS users_count 
        FROM users 
        WHERE birth_date IS NOT NULL 
        GROUP BY birth_date 
    ) a 
    FULL JOIN ( 
        SELECT birth_date, COUNT(courier_id) AS couriers_count 
        FROM couriers 
        WHERE birth_date IS NOT NULL 
        GROUP BY birth_date 
    ) b 
ON a.birth_date = b.birth_date
    ORDER BY users_birth_date ASC, couriers_birth_date ASC

```


#### [Задача 7](https://lab.karpov.courses/learning/152/module/1762/lesson/17929/53217/260437)

<details>

Операции с множествами
Отлично. Запрос с `FULL JOIN` мы вроде бы составили, но как нам теперь определить, что количество записей в полученной таблице совпадает с общим числом уникальных дат в двух таблицах — `users` и `couriers`? Ведь именно столько строк мы и ожидали получить, верно? 

Проверить себя нам помогут операции с множествами. В языке `SQL` их три:

`UNION`
`EXCEPT`
`INTERSECT`
Они позволяют комбинировать результаты нескольких запросов друг с другом и получать один общий результат. Причём именно комбинировать, а не объединять, как это делают джойны.

Эту разницу важно понимать: в операциях с множествами не происходит совмещения столбцов из двух таблиц — база данных просто отбирает строки из таблиц, удовлетворяющие типу операции, и добавляет их в общий результат.

Операции с множествами имеют следующий синтаксис:

```sql
SELECT column_1, column_2
FROM table_1
UNION
SELECT column_1, column_2
FROM table_2


SELECT column_1, column_2
FROM table_1
EXCEPT
SELECT column_1, column_2
FROM table_2


SELECT column_1, column_2
FROM table_1
INTERSECT
SELECT column_1, column_2
FROM table_2
```


Операция `UNION` объединяет записи из двух запросов в один общий результат (объединение множеств).

Операция `EXCEPT` возвращает все записи, которые есть в первом запросе, но отсутствуют во втором (разница множеств).

Операция `INTERSECT` возвращает все записи, которые есть и в первом, и во втором запросе (пересечение множеств).

При этом по умолчанию эти операции исключают из результата строки-дубликаты. Чтобы дубликаты не исключались из результата, необходимо после имени операции указать ключевое слово `ALL`. Например, так:

```sql
SELECT column_1, column_2
FROM table_1
UNION ALL
SELECT column_1, column_2
FROM table_2
```

Диаграммы Венна для операций выглядят следующим образом:

<img width="700" height="195" alt="image" src="https://github.com/user-attachments/assets/5219f272-9ea0-4bd0-8521-aa1222881086" />


Для работы этих операций необходимо, чтобы выполнялись следующие условия:

В каждом запросе в `SELECT` должно быть одинаковое количество столбцов.
Типы данных в столбцах должны быть совместимы.
При этом количество столбцов в операторе `SELECT` может быть любым — главное, чтобы оно было одинаковым.

Например, следующий запрос вернёт уникальные `id` пользователей, которые что-то заказывали в нашем сервисе, но которых по какой-то причине нет в таблице users:

```sql
SELECT user_id
FROM user_actions
EXCEPT
SELECT user_id
FROM users
```

Попробуйте самостоятельно запустить этот запрос в Redash и посмотрите на результат.

`На заметку:`

Подробнее про операцию `UNION` можно узнать здесь. Про `EXCEPT` — здесь. Про `INTERSECT` — тут.

О теории множеств можно почитать [здесь] (https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2#%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F)

</details>

`Задача:` Операции с множествами

Объедините два следующих запроса друг с другом так, чтобы на выходе получился набор уникальных дат из таблиц `users` и `couriers`:

```sql
SELECT birth_date
FROM users
WHERE birth_date IS NOT NULL


SELECT birth_date
FROM couriers
WHERE birth_date IS NOT NULL
```

Поместите в подзапрос полученный после объединения набор дат и посчитайте их количество. Колонку с числом дат назовите `dates_count`.

Поле в результирующей таблице: `dates_count`

После того как решите задачу, сравните полученное число дат с количеством строк в таблице, которую мы получили в прошлом задании. Совпали ли эти значения?

```sql



```
