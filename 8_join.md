# Курс «Симулятор SQL»

## 8 урок JOIN

<details>
Основные типы объединений JOIN
Вот мы и подобрались к одной из важнейших тем в SQL — объединению таблиц. 

SQL-запросы позволяют выбирать и обрабатывать данные не только из одной таблицы — в этом мы уже убедились, когда работали с подзапросами. Но таблицы можно также объединять в один результирующий набор записей, связывая их по определённым условиям. Это позволяет делать операция соединения JOIN.

В этом уроке мы рассмотрим следующие типы соединений таблиц:

INNER JOIN
LEFT/RIGHT JOIN
FULL JOIN
CROSS JOIN
Операторы соединения включаются в раздел FROM запроса. В общем виде, вне зависимости от того, какой тип соединения используется, запрос на объединение таблиц выглядит следующим образом:

```sql
SELECT ...
FROM table_1 
     JOIN table_2
     ON [condition]
...
```

Как правило (но далеко не всегда), в качестве условия [condition], по которому происходит объединение, выступает равенство значений в определённых столбцах. В качестве таких столбцов обычно используются ключи с указанием id (товара, пользователя и т.д.), то есть значений, по которым можно однозначно идентифицировать определённую сущность:

```sql
SELECT table_1.column_1, table_2.column_2
FROM table_1 
     JOIN table_2
     ON table_1.id = table_2.id
...
```


При этом у каждой колонки рекомендуется через точку указывать имя таблицы, которая содержит эту колонку. Более того, это становится уже не рекомендацией, а необходимостью, когда имена столбцов в таблицах совпадают — без явного указания источников база данных не сможет сама определить, какие столбцы и в каких таблицах вы имеете в виду, и в результате вернёт ошибку.

Если имена таблиц слишком длинные, таблицам можно присвоить алиасы. По этим же алиасам можно сразу удобно обращаться к колонкам:

```sql
SELECT a.column_1, b.column_2
FROM table_1 a 
     JOIN table_2 b
     ON a.id = b.id
...
```

Если имя поля, по которому происходит объединение, совпадает в обеих таблицах (как в примерах выше), то можно использовать сокращенную запись c оператором USING:

```sql
SELECT a.column_1, b.column_2
FROM table_1 a 
     JOIN table_2 b
     USING (id)
...
```


При объединении таблиц можно также использовать подзапросы. Их можно объединять с другими таблицами или друг с другом:

```sql
SELECT ...
FROM table_1
     JOIN (
          SELECT ...
          FROM table_2
     ) AS subquery
    ON table_1.id = subquery.id
...
```

```sql
SELECT ...
FROM (
     SELECT ...
     FROM table_1
) AS subquery_1
     JOIN (
          SELECT ...
          FROM table_2
     ) AS subquery_2
    ON subquery_1.id = subquery_2.id
...
```

Хорошо, с записью в общем виде вроде бы понятно. Но что же на самом деле происходит при объединении таблиц? Давайте разбираться.

Процесс объединения можно представить в виде следующей последовательности операций:

Сначала каждая строка первой таблицы сопоставляется с каждой строкой второй таблицы. т.е. происходит декартово произведение двух множеств, результатом которого является новое множество, состоящее из всевозможных пар исходных строк. Например, если в одной таблице было 50 записей, а в другой 10, то в результате декартова произведения получится 500 записей. На игрушечном примере это можно представить следующим образом:

2. Затем для каждой объединённой строки, состоящей из строк двух исходных таблиц, проверяется условие соединения, указанное после оператора ON.

3. После этого в соответствии с выбранным типом объединения формируется результирующая таблица. 

При соединении не двух, а нескольких таблиц, операция соединения выполняется последовательно несколько раз, т.е. описанный выше алгоритм запускается столько раз, сколько указано соединений. При этом в этой последовательности при каждом объединении может использоваться любой тип соединения (INNER, LEFT и т.д.).

Для двух соединений запрос может выглядеть примерно следующим образом:

```sql
SELECT a.column_1, b.column_2
FROM table_1 a 
     LEFT JOIN table_2 b
     ON a.user_id = b.user_id
     JOIN table_3 c
     ON b.order_id = c.order_id
...
```

О том, как именно выбор типа JOIN влияет на результат, мы и будем говорить в этом уроке.

Если что-то на этом шаге осталось непонятным, не переживайте. Сейчас всё проясним на практических примерах!
</details>

### Практика

#### [Задача 1](https://lab.karpov.courses/learning/152/module/1762/lesson/17929/53217/257151)

<details>

Первый тип объединения, который мы рассмотрим, называется INNER JOIN. Это оператор внутреннего соединения, для которого совершенно неважен порядок указания таблиц, т.е. в следующих случаях результат объединения будет одинаковым:

```sql
SELECT ...
FROM table_1 INNER JOIN table_2
     ON [condition]
...


SELECT ...
FROM table_2 INNER JOIN table_1 
     ON [condition]
...
```

При этом в запросе вместо `INNER JOIN` можно писать просто `JOIN` — это одно и то же.

Результат объединения `INNER JOIN` формируется следующим образом:

Сначала каждая строка первой таблицы сопоставляется с каждой строкой второй таблицы (происходит декартово произведение).
Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора ON.
После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
Таким образом, в результате объединения INNER JOIN из двух таблиц отбрасываются все строки, которые не прошли проверку на соответствие указанному условию. Вот и всё!

Рассмотрим следующий игрушечный пример:

```sql
SELECT A.id as id,
       A.city as city,
       B.country as country
FROM table_A as A
     JOIN table_B as B
     ON A.id = B.id
```

В результате такого запроса таблицы table_A и table_B будут объединены в таблицу table_С:
<img width="633" height="253" alt="image" src="https://github.com/user-attachments/assets/4b898240-8999-4453-a4f3-32ab3fae8f69" />


Поскольку таблицы совпадают только по одному значению в столбце id, то в результат будет включена только одна запись.

Схематично результат работы объединений принято изображать в виде диаграмм Венна. Для INNER JOIN диаграмма выглядит так:
<img width="220" height="149" alt="image" src="https://github.com/user-attachments/assets/471dcc15-1313-4354-b9e5-def9b15bd41a" />

`На заметку:`

Подробнее про INNER JOIN можно почитать здесь.

А теперь давайте вернёмся к нашей базе данных и решим задачу.

Для начала попробуйте выполнить в Redash следующие два запроса и посчитать количество уникальных пользователей в таблицах users и user_actions:

```sql
SELECT COUNT(DISTINCT user_id)
FROM users


SELECT COUNT(DISTINCT user_id)
FROM user_actions
```

Вы заметите, что в таблице user_actions уникальных пользователей больше. Это значит, что про часть пользователей мы что-то не знаем — у нас попросту нет о них информации в таблице users. Поэтому в результате соединения этих двух таблиц с помощью INNER JOIN эта часть пользователей будет исключена из результата.

</details>

`Задание:`

Объедините таблицы `user_actions` и `users` по ключу `user_id`. В результат включите две колонки с `user_id` из обеих таблиц. Эти две колонки назовите соответственно user_id_left и user_id_right. Также в результат включите колонки order_id, time, action, sex, birth_date. Отсортируйте получившуюся таблицу по возрастанию id пользователя (в любой из двух колонок с id).

Поля в результирующей таблице: `user_id_left, user_id_right,  order_id, time, action, sex, birth_date`

`Пояснение:`

Обратите внимание, что в результате объединения колонки с ключами (в нашем случае это user_id) не превращаются в одну общую колонку, а вместе добавляются в результирующую таблицу. То есть сколько было суммарно колонок в двух таблицах, столько окажется и в результирующей таблице после объединения. А уже далее в операторе SELECT можно выбирать нужные и проводить над ними операции.

Чтобы обратиться к колонкам с одинаковым именем (user_id), пришедшим из разных таблиц, назначьте таблицам алиасы и обратитесь к колонкам через них. Пример, как это можно сделать:

```sql
SELECT A.id as id_a, 
       B.id as id_b, 
       ...
FROM table_A as A
     JOIN table_B as B
     ON A.id = B.id
...
```

После того как решите задачу, обратите внимание на колонки с user_id. Все ли значения в них попарно совпадают?

```sql

SELECT u.user_id as user_id_left,
       ua.user_id as user_id_right,
       order_id,
       time,
       action,
       sex,
       birth_date
FROM   users as u join user_actions as ua
        ON u.user_id = ua.user_id
ORDER BY u.user_id asc

```

#### [Задача 2](https://lab.karpov.courses/learning/152/module/1762/lesson/17929/53217/257154)

`Задание:`

А теперь попробуйте немного переписать запрос из прошлого задания и посчитать количество уникальных id в объединённой таблице. То есть снова объедините таблицы, но в этот раз просто посчитайте уникальные user_id в одной из колонок с id. Выведите это количество в качестве результата. Колонку с посчитанным значением назовите users_count.

Поле в результирующей таблице: `users_count`

После того как решите задачу, сравните полученное значение с количеством уникальных пользователей в таблицах users и user_actions, которое мы посчитали на прошлом шаге. С каким значением оно совпадает?

```sql

SELECT count(distinct u.user_id) as users_count
FROM   users as u join user_actions as ua
        ON u.user_id = ua.user_id

```

#### [Задача 3](https://lab.karpov.courses/learning/152/module/1762/lesson/17929/53217/257152)

<details>
Следующий тип соединения, который мы рассмотрим, — это LEFT OUTER JOIN (или просто LEFT JOIN). 

LEFT JOIN — это оператор внешнего соединения, для которого важен порядок таблиц в запросе, т.е. в отличие от INNER JOIN он не является симметричным.

Поэтому следующие две записи уже не являются эквивалентными:

```sql
SELECT ...
FROM table_1 LEFT JOIN table_2
     ON [condition]
...


SELECT ...
FROM table_2 LEFT JOIN table_1 
     ON [condition]
...
```

Результат объединения LEFT JOIN формируется следующим образом:

Сначала каждая строка левой таблицы сопоставляется с каждой строкой правой таблицы (происходит декартово произведение).
Затем для каждой объединённой строки проверяется условие соединения, указанное после оператора ON.
После этого все объединённые строки, для которых условие оказалось истинным, добавляются в результирующую таблицу.
Далее в результат добавляются те записи из левой таблицы (внимание: только из левой), для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. При этом для таких записей соответствующие поля из правой таблицы заполняются значениями NULL.
Если внимательно посмотреть на описанный алгоритм, то можно понять, что он легко сводится к следующей последовательности действий:

Сначала в соответствии с указанным условием выполняется INNER JOIN первой и второй таблиц.
Затем в результат добавляются те записи из левой таблицы (внимание: только из левой), для которых условие оказалось ложным и которые не вошли в соединение на предыдущем шаге. При этом для таких записей соответствующие поля из правой таблицы заполняются значениями NULL.
Вот и вся магия!

Соединение RIGHT JOIN работает аналогичным образом, только на втором этапе в результат INNER JOIN добавляются записи не из левой, а из правой таблицы.

Давайте снова рассмотрим пару простых примеров.

Так будет выглядеть запрос и его результат с LEFT JOIN:

```sql
SELECT A.id as id,
       A.city as city,
       B.country as country
FROM table_A as A
     LEFT JOIN table_B as B
     ON A.id = B.id
```
<img width="602" height="271" alt="image" src="https://github.com/user-attachments/assets/50e788fb-8591-45a1-affe-2e905c068226" />


В данном случае в результат попадёт запись с id 2, так как она есть в обеих таблицах, а также запись с id 1 из левой таблицы.

Диаграмма Венна для LEFT JOIN выглядит так:
<img width="220" height="149" alt="image" src="https://github.com/user-attachments/assets/f35960a5-6a35-4185-97c6-8c9afb4adb8e" />


А вот таким получится результат запроса с RIGHT JOIN:

```sql
SELECT B.id as id,
       A.city as city,
       B.country as country
FROM table_A as A
     RIGHT JOIN table_B as B
     ON A.id = B.id
```
<img width="602" height="271" alt="image" src="https://github.com/user-attachments/assets/410998cd-877f-4e50-9dd2-5584e48a78e0" />


Всё как и в случае с LEFT JOIN, только в результат уже попадёт недостающая запись с id 3 из правой таблицы.

Диаграмма Венна для RIGHT JOIN:
<img width="220" height="149" alt="image" src="https://github.com/user-attachments/assets/234fd572-c2e6-4c9c-99f8-175d3365ff23" />

`На заметку:`

Подробнее про LEFT JOIN можно почитать здесь.

А теперь рассмотрим всё на примере наших данных.
</details>

`Задание:`

С помощью LEFT JOIN объедините таблицы `user_actions` и `users` по ключу `user_id`. 
Обратите внимание на порядок таблиц — слева `user_actions`, справа `users`. 
В результат включите две колонки с `user_id` из обеих таблиц. 
Эти две колонки назовите соответственно `user_id_left` и `user_id_right`. 
Также в результат включите колонки `order_id, time, action, sex, birth_date`. 
Отсортируйте получившуюся таблицу по возрастанию id пользователя (в колонке из левой таблицы).

Поля в результирующей таблице: `user_id_left, user_id_right,  order_id, time, action, sex, birth_date`

После того как решите задачу, обратите внимание на колонки с user_id. Нет ли в какой-то из них пропущенных значений?

```sql


```
