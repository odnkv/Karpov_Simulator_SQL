# Курс «Симулятор SQL»

## 4 урок Фильтрация данных

### Практика

#### [Задача 1](https://lab.karpov.courses/learning/152/module/1762/lesson/18485/53202/251020)

<details>

Фильтрация данных позволяет включать в результирующий запрос не все строки исходной таблицы, а только те, которые соответствуют заранее заданному условию.

В SQL для фильтрации данных используется оператор WHERE. После оператора WHERE указывается логическое выражение, результат которого определяет, будет ли строка включена в результирующую таблицу. Если условие оказывается истинным (TRUE), то строка включается в результат, если ложным (FALSE) — строка исключается.

Таким образом, каждая строка в таблице проходит проверку на соответствие определённому условию, и в результате этих проверок формируется таблица, над которой затем проводятся операции, указанные в блоке SELECT.

Оператор WHERE и логическое выражение указываются после блока FROM:

```sql
SELECT column_1, column_2
FROM table
WHERE column_2 >= 0
```

Например, в результате указанного выше запроса в выборку попадут только записи с неотрицательными значениями в колонке column_2.

В свою очередь операторы ORDER BY и LIMIT записываются уже после оператора WHERE. Если добавить их в пример выше, то запрос будет выглядеть так:

```sql
SELECT column_1, column_2
FROM table
WHERE column_2 >= 0
ORDER BY column_1
LIMIT 100
```

В результате мы сначала отфильтруем необходимые нам строки, затем выберем столбцы, отмеченные в SELECT, а потом отсортируем результирующую таблицу, ограничив число выводимых записей.

Таким образом, порядок записи известных нам на текущий момент ключевых слов выглядит так:

```sql
SELECT
FROM
WHERE
ORDER BY
LIMIT
```

Снова обратим внимание, что порядок их выполнения отличается от того, в какой последовательности они указываются в запросе:

Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
Далее WHERE — отфильтровываются строки, соответствующие условию.
Затем SELECT — отбираются указанные столбцы и применяются функции.
Потом ORDER BY — производится сортировка результирующей таблицы.
И в самом конце LIMIT — ограничивается количество выводимых записей.
Иными словами, в результате выполнения запроса сначала происходит подготовка таблицы к работе, а уже затем над ней выполняются разные операции.

`На заметку:`

Подробнее про оператор WHERE можно почитать здесь.

А теперь давайте порешаем задачи на фильтрацию данных и научимся применять оператор WHERE в сочетании с логическими выражениями. Начнём с простого.

</details>

`Задание:`

Напишите SQL-запрос к таблице products и выведите всю информацию о товарах, цена которых не превышает 100 рублей. Результат отсортируйте по возрастанию id товара.

Поля в результирующей таблице: `product_id, name, price`

`Пояснение:`

Если вы успели подзабыть логические выражения, то рекомендуем вернуться к этому шагу.

```sql

SELECT *
FROM   products
WHERE  price <= 100
ORDER BY product_id asc

```

#### [Задача 2](https://lab.karpov.courses/learning/152/module/1762/lesson/18485/53202/288781)

<details>

Фильтровать данные в таблицах можно не только по полям с числовыми значениями, но и по полям со значениями, представленными в виде текста:

```sql
SELECT column_1, column_2
FROM table
WHERE column_2 = 'text'
```

В примере выше в результирующую таблицу попадут только строки, значения в которых полностью совпадают с указанной в WHERE строкой 'text'. 

При сравнении строк также допускается использовать неравенства:

```sql
SELECT column_1, column_2
FROM table
WHERE column_2 > 'text'
```

Впрочем, такая операция используется реже, поскольку не вполне очевидно, что означает «одна строка больше другой».

На самом деле порядок сортировки данных строкового типа обычно определяется заранее установленными правилами сортировки, при которых значение имеют длина строки в символах, порядок букв в соответствии с алфавитом, наличие особых символов, регистр и т.д. Мы не будем подробно останавливаться на этой теме — при желании об этом можно дополнительно прочитать в документации.

`На заметку:`

Подробнее о правилах сортировки данных строкового типа можно почитать здесь.

</details>


`Задание:`

Отберите пользователей женского пола (female) из таблицы users. Выведите только `id` этих пользователей. Результат отсортируйте по возрастанию `id`.

Добавьте в запрос оператор `LIMIT` и выведите только `1000` первых `id` из отсортированного списка.

Поле в результирующей таблице: `user_id`

`Пояснение:`

Обратите внимание, что в SELECT можно не включать колонку, которая используется для фильтрации в операторе WHERE. Так, например, в этом задании мы не включаем в результат колонку с полом пользователя.

```sql

SELECT user_id
FROM   users
WHERE  sex = 'female'
ORDER BY user_id ASC LIMIT 1000

```


#### [Задача 3](https://lab.karpov.courses/learning/152/module/1762/lesson/18485/53202/288782)

<details>
  
В качестве значений для фильтрации можно также использовать даты и время:

```sql
SELECT column_1
FROM table
WHERE column_2 <= '2022-12-31'


SELECT column_1
FROM table
WHERE column_2 <= '2022-12-31 00:00:00'
```

Однако при этом важно заранее убедиться, что в колонке, по которой будут фильтроваться данные, находятся именно даты или отметки времени, а не данные строкового типа, внешне похожие на даты. Если в колонке окажутся строки, то как таковой ошибки не произойдёт, однако результат будет сильно отличаться от ожидаемого.

Также в операциях сравнения дат важно учитывать, что дата всегда интерпретируется как полночь (начало дня), т.е. '2022-12-31' в действительности означает '2022-12-31 00:00:00'.

Кстати, ничто не запрещает нам комбинировать в блоке WHERE разные условия с разными типами данных и создавать более сложные логические выражения:

```sql
SELECT column_1, column_2, column_3
FROM table
WHERE column_1 >= 0 
      AND column_2 = 'some text' 
      AND column_3 = '2022-12-31'
```

Давайте как раз решим задачу сразу с несколькими условиями!

</details>

`Задание:`

Отберите из таблицы `user_actions` все действия пользователей по созданию заказов, которые были совершены ими после полуночи 6 сентября 2022 года. Выведите колонки с `id` пользователей, `id` созданных заказов и временем их создания.

Результат должен быть отсортирован по возрастанию `id` заказа.

Поля в результирующей таблице: `user_id, order_id, time`

`Пояснение:`

Обратите внимание, что в таблице `user_actions` у каждого пользователя могут быть записи не только со временем создания заказа, но и временем его отмены. Нам необходимо получить только записи с созданием заказов.

```sql

SELECT user_id,
       order_id,
       time
FROM   user_actions
WHERE  time > '2022-09-06'
   and action = 'create_order'
ORDER BY order_id asc

```


#### [Задача 4](https://lab.karpov.courses/learning/152/module/1762/lesson/18485/53202/288783)

<details>

В операторе `WHERE` можно использовать не только колонки, которые уже есть в таблице, но в том числе и расчётные колонки. При этом указывать их в `SELECT` опять же не обязательно: 

```sql

SELECT column_1, column_2, (column_1 + column_2) * 0.5 AS average
FROM table
WHERE (column_1 + column_2) * 0.5 = 10


SELECT column_1, column_2
FROM table
WHERE (column_1 + column_2) * 0.5 = 10

```


В примере выше мы отфильтруем только те записи, для которых среднее арифметическое двух чисел, которые содержатся в колонках column_1 и column_2, будет равно 10.

Также важно учитывать, что использовать в блоке WHERE алиасы, присвоенные новым расчётным колонкам, нельзя. Обратите внимание на примеры следующих запросов, которые считают долю значений из колонки column_1 в соответствующих им значениях из колонки column_2. Первый запрос сработает, а второй вернёт ошибку:

-- Этот запрос сработает:

```sql
SELECT column_1, column_2, 
       column_1 / column_2 AS share
FROM table
WHERE column_1 / column_2 > 50
```

-- Этот запрос вернёт ошибку:

```sql
SELECT column_1, column_2, 
       column_1 / column_2 AS share
FROM table
WHERE share > 50
```

Это связано со всё той же последовательностью выполнения операторов в запросе: на момент выполнения оператора WHERE алиас колонке ещё не присвоен, и поэтому база данных пока не знает о существовании колонки с новым именем.

Можно рассмотреть ещё более тривиальный пример: даже если мы просто сделаем дубликат колонки с другим именем и попробуем использовать это имя в WHERE, то всё равно получим ошибку:

-- Этот запрос вернёт ошибку:

```sql
SELECT column, column AS same_column
FROM table
WHERE same_column > 0
```

При указании фильтров в блоке`WHERE` важно учитывать рассмотренные особенности. Можете руководствоваться следующим правилом: если собираетесь фильтровать данные по расчётной колонке, то дублируйте расчёты в WHERE и не используйте алиасы, присвоенные новым колонкам.

</details>

`Задание:`

Назначьте скидку 20% на все товары из таблицы `products` и отберите те, цена на которые с учётом скидки превышает 100 рублей. Выведите `id` товаров, их наименования, прежнюю цену и новую цену с учётом скидки. Колонку со старой ценой назовите `old_price`, с новой — `new_price`.

Результат должен быть отсортирован по возрастанию `id` товара.

Поля в результирующей таблице: `product_id, name, old_price, new_price`

`Пояснение:`

Будьте внимательны, когда будете указывать фильтр после оператора `WHERE`.

```sql

SELECT product_id,
       name,
       price AS old_price,
       (price * 0.8) AS new_price
FROM   products
WHERE  (price * 0.8) > 100
ORDER BY product_id ASC

```


#### [Задача 5](https://lab.karpov.courses/learning/152/module/1762/lesson/18485/53202/288784)

<details>

После оператора `WHERE` к колонкам можно также применять разные функции:

```sql
SELECT column_1, column_2
FROM table 
WHERE LOWER(column_1) = 'karpov.courses'
```

В примере выше каждое значение в колонке `column_1` сначала будет приведено к нижнему регистру, а затем сопоставлено со значением 'karpov.courses'. При этом в результат будут включены исходные значения в колонке `column_1`. Таким образом, функция послужит только для фильтрации записей, но на сами значения в колонках никак не повлияет.

Обратите внимание, что использовать алиасы, присвоенные колонкам в операторе `SELECT`, всё так же нельзя. Следующий запрос вернёт ошибку:

-- Этот запрос вернёт ошибку:

```sql
SELECT column_1 AS new_column_1, column_2
FROM table 
WHERE LOWER(new_column_1) = 'karpov.courses'
```

</details>

`Задание:`

Отберите из таблицы `products` все товары, названия которых либо начинаются со слова «чай», либо состоят из пяти символов. Выведите две колонки: `id` товаров и их наименования.

Результат должен быть отсортирован по возрастанию `id` товара.

Поля в результирующей таблице: `product_id, name`

`Пояснение:`

Для решения задачи вам пригодятся функции `SPLIT_PART и LENGTH`, которые мы рассматривали на прошлом уроке.

`Подсказка`

Для решения задачи в операторе `WHERE` к колонке с названиями товаров необходимо применить функцию `SPLIT_PART`, разделив наименования по пробелу на отдельные слова и отобрав только те, в которых первое слово - «чай». Также через «ИЛИ» необходимо добавить второе условие с функцией `LENGTH` для проверки, что наименование состоит ровно из 5 символов.

```sql

SELECT product_id,
       name
FROM   products
WHERE  name like 'чай %'
    or length(name) = 5
ORDER BY product_id asc

```


#### [Задача 6](https://lab.karpov.courses/learning/152/module/1762/lesson/18485/53202/251021)

<details>

Представьте, что из общего списка наименований товаров нам вдруг понадобилось отобрать определённые позиции, содержащие определённые слова или даже символы. Но при этом мы точно не знаем, в какой части наименования их можно встретить.

Например, нам нужны все «чаи», но они необязательно должны начинаться со слова «чай». Нам также подойдёт «иван-чай» или какой-нибудь «чайный напиток».

Но как это сделать? Неужели нам придётся просматривать всю таблицу, вручную составлять список товаров и писать длинное логическое выражение, учитывающее все возможные сценарии?

Разумеется, не придётся. Для фильтрации по колонкам с текстовыми значениями в SQL предусмотрен оператор `LIKE`.

Оператор `LIKE` не просто сравнивает строки на полное совпадение (или несовпадение), а проверяет их на соответствие заданному шаблону: если строка ему соответствует, то возвращается `TRUE`, в противном случае — `FALSE`.

Шаблоны могут содержать как обычные символы, так и символы-шаблоны: знак процента ( % ) и подчёркивание ( _ ). Подчёркивание подменяет любой одиночный символ, а знак процента — любую (в том числе и пустую) последовательность символов:


```sql
SELECT 'karpov.courses' LIKE 'karpov%'

Результат:
true

SELECT 'karpov.courses' LIKE 'karpov_'

Результат:
false

SELECT 'karpov.courses' LIKE '%karpov%'

Результат:
true

SELECT 'karpov.courses' LIKE '_karpov%'

Результат:
false

SELECT 'karpov.courses' LIKE '%.%'

Результат:
true

SELECT 'karpov.courses' LIKE '_._'

Результат:
false

SELECT 'karpov.courses' LIKE 'Karpov%'

Результат:
false
```

Обратите внимание на последний пример: оператор `LIKE` чувствителен к регистру. Для проверки соответствия строки шаблону символов без учёта регистра можно использовать оператор `ILIKE`:

```sql
SELECT 'KARPOV.COURSES' LIKE '%karpov%'

Результат:
false

SELECT 'KARPOV.COURSES' ILIKE '%karpov%'

Результат:
true
```

Если шаблон не содержит знаков процента и подчёркиваний, тогда шаблон представляет собой строку и `LIKE` работает как оператор сравнения, проверяя строки на точное совпадение.

```sql
SELECT 'karpov.courses' LIKE 'karpov.courses'

Результат:
true

SELECT 'karpov.courses' LIKE 'karpov'

Результат:
false
```

Как можно догадаться, конструкция `NOT LIKE` работает с точностью до наоборот, инвертируя результат работы оператора `LIKE`:

```sql
SELECT 'karpov.courses' NOT LIKE '%kasparov%'

Результат:
true

SELECT 'karpov.courses' NOT LIKE '%karpov%'

Результат:
false
```

`На заметку:`

Подробнее про оператор `LIKE` и шаблоны можно почитать здесь.

</details>

`Задание:`

Отберите из таблицы `products` все товары, содержащие в своём названии последовательность символов «чай» (без кавычек). Выведите две колонки: `id` продукта и его название.

Результат должен быть отсортирован по возрастанию `id` товара.

Поля в результирующей таблице: `product_id, name`


```sql

SELECT product_id,
       name
FROM   products
WHERE  name ilike '%чай%'
ORDER BY product_id asc

```


#### [Задача ]()

<details>

</details>

```sql

```


#### [Задача ]()

<details>

</details>

```sql

```


#### [Задача ]()

<details>

</details>

```sql

```


#### [Задача ]()

<details>

</details>

```sql

```


#### [Задача ]()

<details>

</details>

```sql

```


#### [Задача ]()

<details>

</details>

```sql

```

#### [Задача ]()

<details>

</details>

```sql

```


#### [Задача ]()

<details>

</details>

```sql

```


#### [Задача ]()

<details>

</details>

```sql

```


#### [Задача ]()

<details>

</details>

```sql

```


#### [Задача ]()

<details>

</details>

```sql

```


#### [Задача ]()

<details>

</details>

```sql

```


#### [Задача ]()

<details>

</details>

```sql

```


#### [Задача ]()

<details>

</details>

```sql

```
