# Курс «Симулятор SQL»

## 10 урок Оконные функции

<details>

Оконные функции
Оконными называют функции, которые обрабатывают выделенные наборы строк (окна или партиции) и записывают результаты вычислений в отдельном столбце.

Одно из главных преимуществ оконных функций заключается в том, что они возвращают ровно то же количество записей, которое получили на вход.

Представьте, что вы хотите рассчитать некоторое значение для группы строк, объединённых общим признаком (например, id пользователя). 
Если бы вы воспользовались оператором `GROUP BY`, то на выходе вместо исходного количества строк в группе получили бы одну строку с результатом.

При группировке так происходит всегда — число строк в результирующей таблице всегда равно количеству групп в исходной таблице. 
В то же время оконная функция позволяет проводить те же расчёты с агрегацией по группам, но при этом сохраняет структуру исходной таблицы — для каждой записи, принадлежащей определённой группе, в отдельном столбце просто указывается результат агрегации.

Определяются окна с помощью оператора `OVER` — в общем виде его синтаксис выглядит так:

```sql
OVER (
     PARTITION BY column_1, column_2, ...    - определяются партиции внутри окна (аналог GROUP BY) 
     ORDER BY column_3, ...    - указывается сортировка записей в партициях
     ROWS/RANGE BETWEEN ...    - задаются границы окна
)
```

Для проведения вычислений по заданному в `OVER` окну используются разные функции. Например, с агрегирующей функцией SUM запись может выглядеть следующим образом:

```sql
SELECT SUM(column) OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE BETWEEN ...) AS sum
FROM table
```

Теперь несколько слов об инструкциях, которые можно указывать при создании окна. Всего их три:

```sql
PARTITION BY 
ORDER BY ASC/DESC
ROWS/RANGE BETWEEN
```
При этом все они являются необязательными.

Инструкция `PARTITION BY` определяет столбец, по которому данные будут делиться на группы, которые называются партициями. 
Например, так будет выглядеть группировка по `user_id:`

```sql
SELECT user_id, date, price, 
       SUM(price) OVER (PARTITION BY user_id) AS sum
FROM table
```

В результате такого запроса для каждой записи в таблице будет вычислена общая сумма всех покупок данного пользователя, а результат вычислений будет вписан в столбец sum:
<img width="2366" height="730" alt="image" src="https://github.com/user-attachments/assets/947edead-ed94-442c-a949-c90c7a379d80" />

Инструкция `ORDER BY` определяет столбец, по которому значения внутри окна будут сортироваться при обработке. 
Например, сортировка по date внутри окна задаётся так:

```sql
SELECT user_id, date, price, 
       SUM(price) OVER (PARTITION BY user_id ORDER BY date) AS sum
FROM table
```

В этом случае для каждой записи в таблице будет вычислена сумма текущей и всех предыдущих покупок пользователя. 
Результат вычислений будет вписан в столбец `sum:`

<img width="2374" height="740" alt="image" src="https://github.com/user-attachments/assets/d723d15e-901d-4a3a-b248-812e4bc7f1ca" />

Почему же считается сумма именно текущей и всех предыдущих, а не вообще всех покупок пользователя?

Дело в том, что при использовании оконных функций в паре с агрегирующими для каждой строки определяется так называемая рамка окна — набор строк в её партиции. 
Если в `OVER` указать `ORDER BY`, то по умолчанию рамка будет состоять из всех строк от начала партиции до текущей строки (также в рамку будут включены строки, равные текущей строке по значению, указанному в `ORDER BY`).

Именно поэтому в нашем примере сумма считается по каждому пользователю нарастающим итогом.

Если же `ORDER BY` не указывать, то рамка по умолчанию будет состоять из всех строк партиции, т.е. будет посчитана сумма всех покупок каждого пользователя. 
Также можно не указывать и `PARTITION BY` — тогда рамкой окна станет вся таблица, и мы просто посчитаем сумму покупок всех пользователей:

```sql
SELECT user_id, date, price, 
       SUM(price) OVER () AS sum
FROM table
```

Инструкции `ROWS` и `RANGE` могут дополнительно задавать границы рамки окна и ограничивать диапазон работы функций внутри партиции. 
Первым аргументом указывается начало рамки, вторым — конец рамки:

```sql
SELECT user_id, date, price, 
       SUM(price) OVER (PARTITION BY user_id ORDER BY date ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS sum
FROM table
```

В результате для каждой записи в таблице будет вычислена сумма текущей и предыдущей покупок пользователя, а результат будет снова вписан в столбец `sum`.

<img width="2436" height="742" alt="image" src="https://github.com/user-attachments/assets/455fa079-249c-4356-820e-8fee18bbb211" />

Рамку можно задать в двух режимах:

ROWS — начало и конец рамки определяются строками относительно текущей строки. 
RANGE — начало и конец рамки задаются разницей значений в столбце из ORDER BY.

Начало и конец рамки задаются одним из следующих способов:

```sql
UNBOUNDED PRECEDING
значение PRECEDING
CURRENT ROW
значение FOLLOWING
UNBOUNDED FOLLOWING
```
