# Курс «Симулятор SQL»

## 7 урок Подзапросы

### Практика

#### [Задача 1](https://lab.karpov.courses/learning/152/module/1762/lesson/17928/53213/257121)

<details>
Итак, на лекции мы познакомились с подзапросами (вложенными запросами) и поняли, что в целом их синтаксис ничем не отличается от синтаксиса обычных запросов, которые мы составляли ранее. Иными словами, подзапрос — это всего лишь запрос внутри другого запроса.

Подзапросы могут применяться в следующих частях основного запроса:

`в операторе FROM;
в операторе SELECT (если запрос возвращает один столбец с одним значением);
в операторах WHERE и HAVING (если запрос возвращает один столбец с одним или несколькими значениями);
в операторе CASE при формировании продвинутых условных конструкций.`
Но давайте обо всём по порядку.

Прежде всего важно понять, что к результату выполнения подзапроса можно обращаться так же, как и к таблицам в базе данных, т.е. использовать их в блоке FROM вместо имеющихся таблиц:

```sql
SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM table
) AS subquery_1
```


По сути подзапрос — это такая же таблица, только временная. Она формируется в процессе выполнения основного запроса и нигде не сохраняется.

В примере выше сначала будет выполнен подзапрос, который отберёт колонки column_1 и column_2 из таблицы table, а затем уже из образовавшейся таблицы основной запрос выберет колонку column_1.

`Важный момент`: при использовании подзапроса в блоке FROM сформированной в подзапросе таблице необходимо присвоить какой-нибудь алиас, иначе основной запрос не сработает. В примере выше мы обозначили результат подзапроса как subquery_1.

Приведённый пример довольно условный и на практике колонки таким образом отбирать не стоит, но общую идею он должен передавать.

Давайте рассмотрим ещё один пример. Он тоже довольно условный, но должен помочь нам во всём разобраться. Мы уже знаем, что посчитать число пользователей мужского пола можно двумя способами:

```sql
SELECT sex, COUNT(user_id) AS users_count
FROM users
WHERE sex = 'male'
GROUP BY sex`
```

```sql
SELECT sex, COUNT(user_id) AS users_count
FROM users
GROUP BY sex
HAVING sex = 'male'

```

Но то же самое можно сделать и с помощью подзапроса:

```sql
SELECT sex, users_count
FROM (
    SELECT sex, COUNT(user_id) AS users_count
    FROM users
    GROUP BY sex
) AS subquery
WHERE sex = 'male'
```

Что же здесь произошло? Всё довольно просто: в подзапросе мы сначала сгруппировали наши данные по полу и посчитали число пользователей в каждой группе, а потом обратились к результату этого подзапроса, как к таблице, и отобрали с помощью WHERE нужную нам группу.

Внутри одного запроса может быть сразу несколько подзапросов. Более того, уровней вложенности может быть тоже несколько:

```sql
SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM (
        SELECT column_1, column_2, column_3
        FROM table
    ) AS subquery_1
) AS subquery_2
```

В данном случае последовательность работы запроса такая: сначала будет выполнен подзапрос, возвращающий результат subquery_1, затем подзапрос, возвращающий результат subquery_2, и только потом в результат основного подзапроса попадёт колонка column_1. В результате получается что-то похожее на матрёшку, при этом к основной таблице table обращается только самый первый подзапрос subquery_1.

К колонкам из подзапроса можно применять агрегирующие функции — так же, как если бы мы обращались к колонкам исходных таблиц:

```sql
SELECT MAX(column_sum) AS max_sum
FROM (
    SELECT column_1, SUM(column_2) AS column_sum
    FROM table
    GROUP BY column_1
) AS subquery_1
```


Здесь сначала в подзапросе мы сгруппируем данные по колонке column_1, посчитав для каждой группы сумму значений в колонке column_2, а затем уже в основном запросе найдём максимальное значение среди всех сумм.

На самом деле вариантов того, как можно использовать подзапросы, очень много. Это крайне полезный функционал, который позволяет формировать продвинутые запросы со сложной логикой. Кроме того, понимание, как работают подзапросы в блоке `FROM`, нам особенно пригодится, когда в следующем уроке мы будем учиться объединять таблицы с помощью оператора `JOIN`.

`На заметку:`

Подробнее о том, как работают подзапросы, можно почитать здесь.

А сейчас давайте решим простую задачу.
</details>

`Задание:`

Используя данные из таблицы `user_actions`, рассчитайте среднее число заказов всех пользователей нашего сервиса.

Для этого сначала в подзапросе посчитайте, сколько заказов сделал каждый пользователь, а затем обратитесь к результату подзапроса в блоке `FROM` и уже в основном запросе усредните количество заказов по всем пользователям.

Полученное среднее число заказов всех пользователей округлите до двух знаков после запятой. Колонку с этим значением назовите `orders_avg`.

Поле в результирующей таблице: `orders_avg`

```sql

SELECT round(avg(orders_count), 2) as orders_avg
FROM   (SELECT count(order_id) as orders_count,
               user_id
        FROM   user_actions
        WHERE  action = 'create_order'
        GROUP BY user_id) as subq_1

```

#### [Задача 2](https://lab.karpov.courses/learning/152/module/1762/lesson/17928/53213/257122)

<details>
Решая предыдущую задачу, вы могли задаться вопросами: а что если один и тот же подзапрос будет использоваться в нескольких частях основного запроса? неужели каждый раз придётся дублировать один и тот же подзапрос? а что если уровней вложенности будет несколько? не получится ли тогда слишком сложный и громоздкий запрос, который будет сложно читать?

Для таких случаев в SQL предусмотрен оператор `WITH`, который позволяет создавать так называемые табличные выражения `(CTE, common table expressions)`.

Табличные выражения — это временные таблицы, существующие только для одного запроса. Их основное предназначение заключается в разбиении сложных запросов на несколько частей.

Табличные выражения создаются так:

```sql
WITH 
subquery_1 AS (
    SELECT column_1, column_2
    FROM table
)
```


После оператора `WITH` указывается название табличного выражения (в данном случае это subquery_1), а затем после ключевого слова AS в скобках указывается сам запрос, с помощью которого будет формироваться табличное выражение. Затем в основной части запроса к табличному выражению можно обращаться по имени, как к таблице:

```sql
WITH 
subquery_1 AS (
    SELECT column_1, column_2
    FROM table
)
SELECT column_1
FROM subquery_1
```

Сравните запрос выше с запросом из прошлого шага:

```sql
SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM table
) AS subquery_1
```

Оператор `WITH` может содержать несколько табличных выражений, причём к указанным ранее выражениям можно обращаться в последующих выражениях:

```sql
WITH 
subquery_1 AS (
    SELECT column_1, column_2, column_3
    FROM table
),
subquery_2 AS (
    SELECT column_1, column_2
    FROM subquery_1
)
SELECT column_1
FROM subquery_2
```

Это похоже на код программы: сначала вы создаете некоторые переменные, а затем обращаетесь к ним в последующих её частях. Только в данном случае в качестве переменных выступают таблицы.

Можете снова сравнить запрос выше с запросом из прошлого шага:

```sql
SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM (
        SELECT column_1, column_2, column_3
        FROM table
    ) AS subquery_1
) AS subquery_2
```

Результат обоих запросов будет одинаковым.

Использовать в своих запросах оператор `WITH` или нет — решать вам, но в некоторых случаях он может упростить работу с кодом запроса. 

Предлагаем вам попробовать применить табличные выражения для решения той же самой задачи.

`На заметку:`

Подробнее про `WITH` и табличные выражения можно почитать здесь.

</details>

`Задание:`

Повторите запрос из предыдущего задания, но теперь вместо подзапроса используйте оператор `WITH` и табличное выражение.

Условия задачи те же: используя данные из таблицы `user_actions`, рассчитайте среднее число заказов всех пользователей.

Полученное среднее число заказов округлите до двух знаков после запятой. Колонку с этим значением назовите `orders_avg`.

Поле в результирующей таблице: `orders_avg`

```sql

WITH subq_1 as (SELECT count(order_id) AS orders_count,
                       user_id
                FROM   user_actions
                WHERE  action = 'create_order'
                GROUP BY user_id)
SELECT round(avg(orders_count), 2) AS orders_avg
FROM   subq_1

```

#### [Задача 3](https://lab.karpov.courses/learning/152/module/1762/lesson/17928/53213/257120)

<details>
Ещё одно важное направление применения подзапросов — создание более продвинутых условных выражений в операторах WHERE и HAVING. Но поскольку и в том, и в другом случае синтаксис и назначение подзапросов примерно одинаковые, в этом уроке мы будем рассматривать всё на примере подзапросов в WHERE.

В первую очередь важно понять, что подзапрос, возвращающий одно значение, может использоваться совместно с операторами сравнения.

Иными словами, вы можете составить подзапрос, возвращающий одно значение (как правило, это результат работы агрегирующих функций), а затем сравнить с этим значением (т.е. с подзапросом) все значения в одной из колонок таблицы.

Давайте представим, что нам нужно сравнить значения в каком-то столбце с максимальным, минимальным или средним значением в этом же столбце — такая задача довольно часто встречается на практике. Сделать это в рамках одного запроса точно не получится, поскольку, как мы уже знаем, агрегирующие функции нельзя применять в блоке `WHERE`.

Первое, что приходит в голову, — написать примерно такой запрос:

```sql
SELECT column
FROM table
WHERE column = MAX(column) 
```
Но по понятным причинам работать он не будет, и база данных сообщит об ошибке.

Однако хотя запрос и некорректный, его логика в целом правильная: нам действительно нужно найти максимальное значение в колонке и сравнить с ним все значения в этой же колонке. Единственное, что мы забыли, когда считали максимальное значение, это обратиться к самой таблице.

Давайте это исправим и перепишем запрос следующим образом:

```sql
SELECT column
FROM table
WHERE column = (SELECT MAX(column) FROM table)
```

В результате выполнения такого запроса мы получим все значения в колонке column, равные максимальному значению в этой колонке.

Такой запрос отработает уже без ошибок, так как подзапрос с расчётом максимального значения выполнится первым и вернёт одно значение.

А теперь ещё одна несложная задача.
</details>

`Задание:`

Выведите из таблицы `products` информацию о всех товарах кроме самого дешёвого.

Результат отсортируйте по убыванию `id` товара.

Поля в результирующей таблице: `product_id, name, price`

```sql

WITH subq_1 AS (SELECT min(price) AS min_price
                FROM   products)
SELECT *
FROM   products
WHERE  price != (SELECT min_price
                 FROM   subq_1)
ORDER BY product_id DESC

```

#### [Задача 4](https://lab.karpov.courses/learning/152/module/1762/lesson/17928/53213/257124)
<details>
Результат подзапроса, возвращающего столбец с одним значением, также можно использовать в арифметических операциях:

```sql
SELECT column
FROM table
WHERE column = (SELECT MAX(column) FROM table) - 100`
```

Более того, с помощью подзапросов вы можете брать необходимые вам значения из нескольких разных таблиц и использовать их в качестве переменных внутри основного запроса:

```sql
SELECT column
FROM table
WHERE column >= (SELECT MAX(column_1) FROM table_1) - 100
    AND column <= (SELECT MAX(column_2) FROM table_2)`
```

То есть в данном случае результат выполнения подзапроса можно рассматривать как некоторую переменную. Со временем число записей в таблицах может меняться (допустим, появляются новые товары по новым ценам или новые заказы с более поздними датами), и наши подзапросы будут это учитывать, каждый раз заново рассчитывая необходимые нам значения — согласитесь, довольно удобный функционал.

`На заметку:`

Если же в одном запросе используется несколько разных «переменных» из подзапросов или к одному и тому же подзапросу нужно обращаться несколько раз, тогда имеет смысл вынести эти подзапросы в начало основного запроса в виде табличных выражений в блоке WITH.

```sql
WITH 
subquery AS (
    SELECT MAX(column_2)
    FROM table_2
)

SELECT column_1
FROM table_1
WHERE column_1 = (SELECT * FROM subquery)
```

Обратите внимание на запись со «звёздочкой». Дело в том, что обратиться к этим «переменным» просто по имени табличного выражения не получится — придётся отдельным подзапросом из табличного выражения выбрать рассчитанное значение. Самый простой вариант — написать подзапрос с SELECT * из табличного выражения.

Если «переменных» несколько, то запрос может выглядеть так:

```sql
WITH
subquery_1 AS (
    SELECT MAX(column_1)
    FROM table_1
),
subquery_2 AS (
    SELECT MAX(column_2)
    FROM table_2
)


SELECT column
FROM table
WHERE column >= (SELECT * FROM subquery_1) - 100
    AND column <= (SELECT * FROM subquery_2)`
```

Такая запись может показаться громоздкой, но в некоторых случаях, когда одни и те же подзапросы необходимо использовать несколько раз по ходу основного запроса, она может существенно упростить ваш код.

Но давайте вернёмся к нашим таблицам.
</details>

`Задание:`

Выведите информацию о товарах в таблице `products`, цена на которые превышает среднюю цену всех товаров на 20 рублей и более. Результат отсортируйте по убыванию `id` товара.

Поля в результирующей таблице: `product_id, name, price`

```sql
WITH subq_1 AS (SELECT avg(price)+20 AS avg_price
                FROM   products)
SELECT *
FROM   products
WHERE  price > (SELECT avg_price
                FROM   subq_1)
ORDER BY product_id DESC
```

#### [Задача 5](https://lab.karpov.courses/learning/152/module/1762/lesson/17928/53213/257125)
<details>
В каких ещё случаях на практике нам может пригодиться подзапрос в операторе WHERE?

Давайте представим, что нам нужно провести какие-нибудь расчёты за последние N дней — скажем, за последнюю неделю. Не будем же мы вручную отсчитывать 7 дней от последней даты в нашей таблице? Разумеется, не будем, так как последняя дата может со временем измениться, когда к нам поступят новые данные. Каждый раз писать новый запрос и считать дату вручную — занятие не для нас.

Для решения такой задачи мы можем сначала с помощью подзапроса вычислить последнюю дату в наших данных, а затем отложить от неё неделю.

Чтобы отложить от даты или прибавить к ней какой-то промежуток времени, можно использовать несложные арифметические операции с датами. Например, от текущей даты можно отнять заданный промежуток `INTERVAL`:

```sql
SELECT NOW() - INTERVAL '1 year 2 months 1 week'

Результат:
10/10/21 19:32`
```

Кстати, NOW — полезная функция, которая позволяет получать текущую дату и время (в вашем случае она будет другой, как и результат запроса выше):

```sql
SELECT NOW()

Результат:
17/12/22 19:32`
```

`На заметку:`

С другими примерами работы с `INTERVAL` и арифметическими операциями с датами можно ознакомиться здесь.

Про функцию `NOW` можно дополнительно почитать тут.
</details>

`Задание:`

Посчитайте количество уникальных клиентов в таблице `user_actions`, сделавших за последнюю неделю хотя бы один заказ.

Полученную колонку с числом клиентов назовите `users_count`. В качестве текущей даты, от которой откладывать неделю, используйте последнюю дату в той же таблице `user_actions`.

Поле в результирующей таблице: `users_count`

```sql
SELECT
  COUNT(DISTINCT user_id) AS users_count
FROM user_actions
WHERE action = 'create_order' AND time BETWEEN (SELECT MAX(time) FROM user_actions) - interval '1 week' 
AND (SELECT MAX(time) FROM user_actions)

```

#### [Задача 6](https://lab.karpov.courses/learning/152/module/1762/lesson/17928/53213/257126)
<details>
Получается, что в одном из прошлых уроков мы неправильно считали возраст курьеров!

Действительно, тогда мы ничего не знали про подзапросы и в качестве первой даты в функции AGE указывали текущую дату, а не последнюю дату в данных. Давайте исправим это досадное недоразумение, ведь теперь у нас для этого есть все необходимые знания.

Но прежде сделаем небольшое, но важное уточнение: подзапросы могут выступать в качестве аргументов функций, т.е. к результату выполнения подзапросов можно применять функции, принимающие на вход какие-то значения. Так, например, подзапросы можно указывать в качестве аргументов функций CONCAT или COALESCE:

```sql
SELECT CONCAT(
              'Начало периода: ', (SELECT MIN(date) FROM table), 
              ' ', 
              'Конец периода: ', (SELECT MAX(date) FROM table)
       )

SELECT COALESCE((SELECT MAX(date) FROM table), NOW())`
```

В таком случае результат выполнения подзапроса будет подставляться в функцию для дальнейших расчётов.
</details>

`Задание:`

С помощью функции `AGE` и агрегирующей функции снова определите возраст самого молодого курьера мужского пола в таблице `couriers`, но в этот раз при расчётах в качестве первой даты используйте последнюю дату из таблицы `courier_actions`.

Чтобы получить именно дату, перед применением функции `AGE` переведите последнюю дату из таблицы `courier_actions` в формат `DATE`, как мы делали в [этом задании](https://lab.karpov.courses/learning/152/module/1762/lesson/18484/53190/250927/).

Возраст курьера измерьте количеством лет, месяцев и дней и переведите его в тип `VARCHAR`. Полученную колонку со значением возраста назовите `min_age`.

Поле в результирующей таблице: `min_age`

```sql
SELECT
MIN(AGE((SELECT MAX(time)::date FROM courier_actions), birth_date))::varchar AS min_age
FROM couriers
WHERE sex = 'male'

```

#### [Задача 7](https://lab.karpov.courses/learning/152/module/1762/lesson/17928/53213/257127)

<details>
Всё это время мы говорили о подзапросах, возвращающих одно значение в результате применения агрегирующих функций. Теперь рассмотрим случаи, когда подзапрос возвращает несколько значений, и узнаем, как это можно использовать для продвинутой фильтрации данных в таблицах.

Подзапрос, возвращающий несколько значений, может использоваться в блоке WHERE совместно с оператором IN — например, когда нам нужно проверить, совпадает ли значение в столбце с одним из значений из определённого множества, полученного в результате выполнения подзапроса.

Выглядит это так:

```sql
SELECT column_1
FROM table_1
WHERE column_1 IN (SELECT column_2 FROM table_2)`
```
Сначала подзапрос отберёт все значения в колонке column_2 из таблицы table_2, а затем выберет те записи из таблицы table_1, где в колонке column_1 значение совпадает с одним из значений в колонке column_2, полученной в результате подзапроса. Обратите внимание, что использовать DISTINCT в подзапросе необязательно, т.к. на результат основного запроса это никак не повлияет — по большому счёту нет разницы, будут значения в списке уникальными или нет.

При этом запрос выше будет равносилен запросу с табличным выражением:

```sql
WITH 
subquery AS (
    SELECT column_2
    FROM table_2
)

SELECT column_1
FROM table_1
WHERE column_1 IN (SELECT * FROM subquery) `
```

Снова обратите внимание, что при использовании в операторе WHERE табличного выражения обратиться просто к его имени нельзя — необходимо предварительно выбрать все его записи, т.е. написать подзапрос. При этом в табличном выражении должен быть всего один столбец, иначе база данных вернёт ошибку.

Давайте рассмотрим следующий пример.

Из наших данных довольно легко отобрать отменённые заказы — достаточно указать в WHERE нужный фильтр. Но как отобрать созданные, но неотменённые заказы? Это как раз можно сделать с помощью подзапроса или табличного выражения. Давайте попробуем это сделать.
</details>

`Задание:`

Из таблицы `user_actions` с помощью подзапроса или табличного выражения отберите все заказы, которые не были отменены пользователями.

Выведите колонку с `id` этих заказов. Результат запроса отсортируйте по возрастанию `id` заказа.

Добавьте в запрос оператор `LIMIT` и выведите только первые 1000 строк результирующей таблицы.

Поле в результирующей таблице: `order_id`

```sql

WITH subq_1 AS (SELECT order_id
                FROM   user_actions
                WHERE  action = 'cancel_order')
SELECT order_id
FROM   user_actions
WHERE  order_id not IN (SELECT *
                        FROM   subq_1)
ORDER BY order_id ASC LIMIT 1000

```

#### [Задача 8](https://lab.karpov.courses/learning/152/module/1762/lesson/17928/53213/257123)

<details>
В начале урока мы отметили, что вложенный запрос может располагаться и после оператора SELECT. Однако тогда результатом подзапроса может быть только одно значение — например, результат применения агрегирующей функции к некоторой колонке:

```sql
SELECT column_1, (SELECT MAX(column_1) FROM table) AS max_column_1
FROM table`
```

В этом примере из таблицы table будет выбрана колонка column_1, и напротив каждого значения в этой колонке будет выведен результат выполнения вложенного запроса, т.е. максимальное значение в колонке. При этом давать алиас результату подзапроса не обязательно.

По сути эта операция равносильно тому, как если бы мы просто проставили одно и то же значение в отдельном столбце, посчитав его вручную:

```sql
SELECT column_1, 1500 AS max_column_1
FROM table
```

Разница заключается в том, что с помощью подзапроса мы делаем это значение динамическим и избавляем себя от необходимости постоянно его обновлять.

Также результаты подзапросов в блоке SELECT можно сразу использовать в вычислениях:

```sql
SELECT column_1, (SELECT MAX(column_1) FROM table) - 100 AS column_2
FROM table
```


На практике подзапрос в SELECT может использоваться для того, чтобы сравнить значения в колонке с каким-нибудь одним расчётным значением (из той же или другой таблицы):

```sql
SELECT column_1, column_2, column_2 > (SELECT MAX(column_1) FROM table) AS column_3
FROM table
```

`На заметку:`

На самом деле для того, чтобы в отдельном столбце вывести расчёты с агрегацией по колонкам в той же таблице, не меняя при этом её структуру, чаще используются не подзапросы, а оконные функции — продвинутый функционал, который мы будем рассматривать в конце первого модуля курса.

Сейчас с помощью имеющихся на данный момент знаний мы попробуем решить задачу, не прибегая к продвинутым инструментам. Можете вернуться к этой задаче после прохождения последнего урока и попробовать решить её с помощью оконных функций.
</details>

`Задание:`

Используя данные из таблицы `user_actions`, рассчитайте, сколько заказов сделал каждый пользователь и отразите это в столбце `orders_count`.

В отдельном столбце `orders_avg` напротив каждого пользователя укажите среднее число заказов всех пользователей, округлив его до двух знаков после запятой.

Также для каждого пользователя посчитайте отклонение числа заказов от среднего значения. Отклонение считайте так: число заказов «минус» округлённое среднее значение. Колонку с отклонением назовите `orders_diff`.

Результат отсортируйте по возрастанию `id` пользователя. Добавьте в запрос оператор `LIMIT` и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: `user_id, orders_count, orders_avg, orders_diff`

`Пояснение:`

В этой задаче можно использовать подзапрос, написанный в первых заданиях этого урока. Чтобы не пришлось дважды писать один и тот же подзапрос, можно использовать оператор WITH.

```sql

WITH 
subq_1 AS (SELECT 
COUNT(DISTINCT order_id) AS orders_count,
user_id
FROM user_actions
WHERE action = 'create_order'
GROUP BY user_id),

subq_2 AS (SELECT ROUND(AVG(orders_count),2) AS orders_avg FROM subq_1)

SELECT 
user_id, 
orders_count, 
(SELECT * FROM subq_2) AS orders_avg,
orders_count - (SELECT * FROM subq_2) AS orders_diff

FROM subq_1 
ORDER BY user_id 
LIMIT 1000

```

#### [Задача 9](https://lab.karpov.courses/learning/152/module/1762/lesson/17928/53213/257133)

<details>
Подзапросы также могут использоваться в операторе CASE при формировании сложных условных конструкций. Это бывает полезно, когда необходимо сравнить значения в некотором столбце с одним значением, рассчитанным по той же или другой таблице. Или, например, в случаях, когда для каждой записи в таблице нужно проверить вхождение значения в колонке в определённое множество значений из другой таблицы.

Допустим, у нас есть две таблицы, в которых хранятся почты старых и новых клиентов, и нам необходимо «подтянуть» эту информацию в таблицу c заказами. Сделать это можно так:

```sql
SELECT client_id, email, order_id,
    CASE 
    WHEN email IN (SELECT email FROM clients_new)
    THEN 'new'
    WHEN email IN (SELECT email FROM clients_old)
    THEN 'old'
    ELSE 'unknown'
    END AS client_type
FROM orders
```


Вариантов применения подзапросов в операторе CASE — огромное множество. Давайте применим новые знания на наших данных и попробуем назначить скидку с учетом того, насколько сильно цена на товар отличается от средней цены всех товаров.
</details>

`Задание:`

Назначьте скидку 15% на товары, цена которых превышает среднюю цену на все товары на 50 и более рублей, а также скидку 10% на товары, цена которых ниже средней на 50 и более рублей. Цену остальных товаров внутри диапазона (среднее - 50; среднее + 50) оставьте без изменений. При расчёте средней цены, округлите её до двух знаков после запятой.

Выведите информацию о всех товарах с указанием старой и новой цены. Колонку с новой ценой назовите `new_price`.

Результат отсортируйте сначала по убыванию прежней цены в колонке `price`, затем по возрастанию `id` товара.

Поля в результирующей таблице: `product_id, name, price, new_price`

`Пояснение:`

Чтобы не пришлось дважды писать один и тот же подзапрос, рекомендуем в этой задаче использовать оператор `WITH`.

```sql
WITH 
subq_1 AS (SELECT ROUND(AVG(price),2) AS avg_price
FROM products)

SELECT 
product_id,
name,
price,

CASE 
    WHEN price >= (SELECT avg_price FROM subq_1)+50 THEN price*0.85
    WHEN price <= (SELECT avg_price FROM subq_1)-50 THEN price*0.9
    ELSE price
END AS new_price
FROM products 
ORDER BY price DESC, product_id ASC

```

#### [Задача 10](https://lab.karpov.courses/learning/152/module/1762/lesson/17928/53213/353794)
<details>
    
НОВАЯ ЗАДАЧА

Всё это время мы решали задачи и даже не задумывались о том, можно ли вообще доверять данным, которые оказались в нашем распоряжении. Но ошибаются не только аналитики — ошибки в расчётах могут быть связаны с проблемами на любом этапе работы с данными. И далеко не все эти этапы мы можем контролировать. Но вместо того, чтобы потом разбираться, кто больше ошибся, лучше заранее убедиться, что в данных нет очевидных несостыковок. Делать это стоит всегда — даже если об этом вас явно не просят.

Впрочем, в своё оправдание мы можем сказать, что раньше у нас было не так много знаний, чтобы что-то проверять. Однако сейчас, когда мы добрались до подзапросов, какие-то очевидные ошибки мы уже можем выявить.

Мы уже знаем, как работает наш сервис: пользователи создают заказы, курьеры их принимают, а затем доставляют, если эти заказы не отменяются. Но может ли быть такое, что какой-то заказ доставляется, но при этом не создаётся? То есть заказ с некоторым id есть в числе доставленных в таблице courier_actions, но его нет среди созданных в таблице user_actions? Вы спросите: разве так может быть? Вполне, если наш сервис работает с ошибками и на каком-то этапе что-то идёт не по плану.

Ну что же, давайте попробуем поискать такие заказы.
</details>

`Задание:`

Выясните, есть ли в таблице courier_actions такие заказы, которые были приняты курьерами, но не были созданы пользователями. Посчитайте количество таких заказов.

Колонку с числом заказов назовите `orders_count`.

Поле в результирующей таблице: `orders_count`

```sql

SELECT count(distinct order_id) as orders_count
FROM   courier_actions
WHERE  action = 'accept_order'
   and order_id NOT IN (SELECT DISTINCT order_id
                     FROM   user_actions)

```

#### [Задача 11](https://lab.karpov.courses/learning/152/module/1762/lesson/17928/53213/353795)

<details>
НОВАЯ ЗАДАЧА

Хорошо, проверку на наличие очевидных ошибок мы сделали. Теперь давайте копнём немного глубже.

Мы знаем, что в данных о действиях курьеров есть две отметки времени: время принятия и время доставки заказа. Но все ли из принятых заказов числятся в данных как доставленные? Вряд ли, потому что заказ, во-первых, могли отменить, а во-вторых, его могли просто не успеть доставить.

Давайте проверим, так ли это на самом деле. Для начала просто определим заказы, которые не доставили.
</details>

`Задание:`

Выясните, есть ли в таблице user_actions такие заказы, которые были приняты курьерами, но не были доставлены пользователям: у заказа нет записи с действием 'deliver_order' в таблице `courier_actions`. Посчитайте уникальное количество таких заказов: используйте count(distinct order_id).

Колонку с числом заказов назовите `orders_count`.

Поле в результирующей таблице: `orders_count`

```sql

SELECT count(distinct order_id) as orders_count
FROM   user_actions
WHERE  order_id NOT IN (SELECT order_id
                        FROM   courier_actions
                        WHERE  action = 'deliver_order')

```

#### [Задача 12](https://lab.karpov.courses/learning/152/module/1762/lesson/17928/53213/353796)

<details>
НОВАЯ ЗАДАЧА

Погодите, а может ли быть так, что курьеры каким-то образом доставляют отменённые заказы? Допустим, курьер привёз заказ, который пользователь отменил в процессе доставки, и в результате мы получили и запись о доставке в таблице `courier_actions`, и запись об отмене в таблице `user_actions`. 

А что, в целом звучит правдоподобно. Давайте проверим и это.
</details>

`Задание:`

Определите количество отменённых заказов в таблице `courier_actions` и выясните, есть ли в этой таблице такие заказы, которые были отменены пользователями, но при этом всё равно были доставлены. Посчитайте количество таких заказов.

Колонку с отменёнными заказами назовите `orders_canceled`. Колонку с отменёнными, но доставленными заказами назовите `orders_canceled_and_delivered`. 

Поля в результирующей таблице: `orders_canceled, orders_canceled_and_delivered`

`Пояснение:`

Для решения задачи пригодится оператор FILTER, который мы рассматривали в этом уроке.

```sql

SELECT count(order_id) as orders_canceled,
       count(order_id) filter (WHERE action = 'deliver_order') as orders_canceled_and_delivered
FROM   courier_actions
WHERE  order_id IN (SELECT order_id
                    FROM   user_actions
                    WHERE  action = 'cancel_order')

```

#### [Задача 13](https://lab.karpov.courses/learning/152/module/1762/lesson/17928/53213/353797)

<details>
НОВАЯ ЗАДАЧА

Отлично! Ещё одну проверку на ошибки мы сделали и теперь можем вернуться к недоставленным заказам.

Мы уже выяснили, что такие есть и предположили, что среди них могут быть как заказы, отменённые пользователями, так и заказы, которые ещё не успели доставить.

Количество отменённых заказов мы уже считали. Теперь давайте выясним, есть ли такие заказы, которые не были отменены, но и не были доставлены — то есть заказы, которые находятся в процессе доставки. Таким образом мы поймём, все ли заказы были доставлены на момент обращения к данным.
</details>

`Задание:`

По таблицам `courier_actions` и `user_actions` снова определите число недоставленных заказов и среди них посчитайте количество отменённых заказов и количество заказов, которые не были отменены (и соответственно, пока ещё не были доставлены).

Колонку с недоставленными заказами назовите `orders_undelivered`, колонку с отменёнными заказами назовите `orders_canceled`, колонку с заказами «в пути» назовите `orders_in_process`.

Поля в результирующей таблице: `orders_undelivered, orders_canceled, orders_in_process`

`Пояснение:`

Для решения задачи пригодится оператор FILTER, который мы рассматривали в этом уроке.

`На заметку:`

Подзапросы можно также использовать и в операторе FILTER для формирования ещё более продвинутых условий фильтрации. В таком случае конструкция будет иметь следующий вид:

```sql
SELECT COUNT(column) FILTER (WHERE column > (SELECT AVG(column) FROM table)) AS count
FROM table`
```


Такой запрос посчитает количество значений в колонке column, которые превышают среднее значение по этой же колонке. Разумеется, в подзапросе, указанном в FILTER, можно обращаться и к другим колонкам и таблицам, применяя любые другие способы фильтрации — например, оператор IN:

```sql
SELECT COUNT(column_1) FILTER (WHERE column_1 IN (SELECT column_2 FROM table_2)) AS count
FROM table_1
```


Для решения этой задачи использовать подзапросы в операторе FILTER не обязательно, но попробовать можно.


```sql

SELECT 
COUNT(DISTINCT order_id) AS orders_undelivered,
COUNT(order_id) FILTER (WHERE action = 'cancel_order') AS orders_canceled,
COUNT(distinct order_id) - COUNT(order_id) FILTER (WHERE action = 'cancel_order') AS orders_in_process
FROM user_actions
WHERE order_id IN
(SELECT order_id
FROM courier_actions 
WHERE order_id NOT IN (SELECT order_id FROM courier_actions WHERE action = 'deliver_order'))

```
